directive @embedded on OBJECT

directive @collection(name: String!) on OBJECT

directive @index(name: String!) on FIELD_DEFINITION

directive @resolver(
  name: String
  paginated: Boolean! = false
) on FIELD_DEFINITION

directive @relation(name: String) on FIELD_DEFINITION

directive @unique(index: String) on FIELD_DEFINITION

type Block {
  """
  The block number
  """
  number: Long!

  """
  The document's ID.
  """
  _id: ID!

  """
  The hash of the block
  """
  hash: ID!
  tokens(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): TokenPage!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
'Block' input values
"""
input BlockInput {
  """
  The hash of the block
  """
  hash: ID!

  """
  The block number
  """
  number: Long!
  tokens: BlockTokensRelation
}

"""
The pagination object for elements of type 'Block'.
"""
type BlockPage {
  """
  The elements of type 'Block' in this page.
  """
  data: [Block]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

"""
Allow manipulating the relationship between the types 'Block' and 'Token'.
"""
input BlockTokensRelation {
  """
  Create one or more documents of type 'Token' and associate them with the current document.
  """
  create: [TokenInput]

  """
  Connect one or more documents of type 'Token' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Token' from the current document using their IDs.
  """
  disconnect: [ID]
}

"""
Content correspnoding to a resource(s) that were referreced by non-fungible
token metadata. It is identified and unique by it's cid. Content may represent
a file, directory or arbitrary Dag in IPFS network.
"""
type Content {
  """
  The document's ID.
  """
  _id: ID!

  """
  Root CID for this content.
  """
  cid: String!

  """
  Size of the DAG in bytes. Set if known on upload or for partials is set when
  content is fully pinned in at least one location.
  """
  dagSize: Int

  """
  IPFS nodes pinning this content.
  """
  pins(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): PinPage!

  """
  Backlikns to al lthe resources that resolve to this content. Note that
  different resource URIs may resolve to the same CID.
  """
  resources(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): ResourcePage!

  """
  Creation date.
  """
  created: Time!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
'Content' input values
"""
input ContentInput {
  """
  Root CID for this content.
  """
  cid: String!

  """
  Backlikns to al lthe resources that resolve to this content. Note that
  different resource URIs may resolve to the same CID.
  """
  resources: ContentResourcesRelation

  """
  IPFS nodes pinning this content.
  """
  pins: ContentPinsRelation

  """
  Size of the DAG in bytes. Set if known on upload or for partials is set when
  content is fully pinned in at least one location.
  """
  dagSize: Int

  """
  Creation date.
  """
  created: Time!
}

"""
Allow manipulating the relationship between the types 'Content' and 'Pin'.
"""
input ContentPinsRelation {
  """
  Create one or more documents of type 'Pin' and associate them with the current document.
  """
  create: [PinInput]

  """
  Connect one or more documents of type 'Pin' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Pin' from the current document using their IDs.
  """
  disconnect: [ID]
}

"""
Allow manipulating the relationship between the types 'Content' and 'Resource'.
"""
input ContentResourcesRelation {
  """
  Create one or more documents of type 'Resource' and associate them with the current document.
  """
  create: [ResourceInput]

  """
  Connect one or more documents of type 'Resource' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Resource' from the current document using their IDs.
  """
  disconnect: [ID]
}

type Cursor {
  """
  The document's ID.
  """
  _id: ID!

  """
  The document's timestamp.
  """
  _ts: Long!
  id: String!
}

"""
'Cursor' input values
"""
input CursorInput {
  id: String!
}

scalar Date

input ERC721ImportInput {
  """
  Cursor from which import started. If current cursor changed import will be
  rejected.
  """
  id: String!

  """
  Tokens to be imported.
  """
  tokens: [ERC721ImportTokenInput!]!
}

type ERC721ImportResult {
  """
  The document's ID.
  """
  _id: ID!

  """
  New cursor after this import.
  """
  nextID: String!

  """
  Cursor from which import started.
  """
  id: String!

  """
  Tokens that were imported.
  """
  tokens(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): TokenPage!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
'ERC721ImportResult' input values
"""
input ERC721ImportResultInput {
  """
  Cursor from which import started.
  """
  id: String!

  """
  New cursor after this import.
  """
  nextID: String!

  """
  Tokens that were imported.
  """
  tokens: ERC721ImportResultTokensRelation
}

"""
The pagination object for elements of type 'ERC721ImportResult'.
"""
type ERC721ImportResultPage {
  """
  The elements of type 'ERC721ImportResult' in this page.
  """
  data: [ERC721ImportResult]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

"""
Allow manipulating the relationship between the types 'ERC721ImportResult' and 'Token'.
"""
input ERC721ImportResultTokensRelation {
  """
  Create one or more documents of type 'Token' and associate them with the current document.
  """
  create: [TokenInput]

  """
  Connect one or more documents of type 'Token' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Token' from the current document using their IDs.
  """
  disconnect: [ID]
}

input ERC721ImportTokenContractInput {
  id: ID!
  name: String
  symbol: String
  supportsEIP721Metadata: Boolean!
}

input ERC721ImportTokenInput {
  id: ID!
  tokenID: String!
  tokenURI: String!
  mintTime: String!
  blockHash: String!
  blockNumber: String!
  contract: ERC721ImportTokenContractInput!
  owner: ERC721ImportTokenOwnerInput!
}

input ERC721ImportTokenOwnerInput {
  id: ID!
}

input ERC721MetadataQuery {
  name: String
  symbol: String
  tokenURI: String
  ipnft: String
}

input FindResourceInput {
  status: ResourceStatus
}

input FindTokenAssetsInput {
  status: TokenAssetStatus
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

input MetadaQuery {
  name: String
  description: String
  image: ResourceQuery
}

type Metadata {
  """
  Identifies the asset this token represents
  """
  name: String!
  source: TokenAsset!

  """
  Additional assets that token linked to
  """
  assets(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): ResourcePage!

  """
  A file representing the asset this token represents
  """
  image: Resource!

  """
  Describes the asset this token represents
  """
  description: String!

  """
  The document's ID.
  """
  _id: ID!

  """
  Content corresponding to the metadata.
  """
  content: Content!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
Allow manipulating the relationship between the types 'Metadata' and 'Resource'.
"""
input MetadataAssetsRelation {
  """
  Create one or more documents of type 'Resource' and associate them with the current document.
  """
  create: [ResourceInput]

  """
  Connect one or more documents of type 'Resource' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Resource' from the current document using their IDs.
  """
  disconnect: [ID]
}

"""
Allow manipulating the relationship between the types 'Metadata' and 'Content' using the field 'Metadata.content'.
"""
input MetadataContentRelation {
  """
  Create a document of type 'Content' and associate it with the current document.
  """
  create: ContentInput

  """
  Connect a document of type 'Content' with the current document using its ID.
  """
  connect: ID
}

"""
Allow manipulating the relationship between the types 'Metadata' and 'Resource' using the field 'Metadata.image'.
"""
input MetadataImageRelation {
  """
  Create a document of type 'Resource' and associate it with the current document.
  """
  create: ResourceInput

  """
  Connect a document of type 'Resource' with the current document using its ID.
  """
  connect: ID
}

input MetadataInput {
  """
  CID for the metadata content.
  """
  cid: String!

  """
  Identifies the asset this token represents
  """
  name: String!

  """
  Describes the asset this token represents
  """
  description: String!

  """
  A file representing the asset this token represents
  """
  image: ResourceInput!
  assets: [ResourceInput!]!
}

"""
The pagination object for elements of type 'Metadata'.
"""
type MetadataPage {
  """
  The elements of type 'Metadata' in this page.
  """
  data: [Metadata]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

"""
Allow manipulating the relationship between the types 'Metadata' and 'TokenAsset' using the field 'Metadata.source'.
"""
input MetadataSourceRelation {
  """
  Create a document of type 'TokenAsset' and associate it with the current document.
  """
  create: TokenAssetInput

  """
  Connect a document of type 'TokenAsset' with the current document using its ID.
  """
  connect: ID

  """
  If true, disconnects this document from 'TokenAsset'
  """
  disconnect: Boolean
}

type Mutation {
  """
  Delete an existing document in the collection of 'Owner'
  """
  deleteOwner(
    """
    The 'Owner' document's ID
    """
    id: ID!
  ): Owner

  """
  Create a new document in the collection of 'Pin'
  """
  createPin(
    """
    'Pin' input values
    """
    data: PinInput!
  ): Pin!

  """
  Delete an existing document in the collection of 'TokenAsset'
  """
  deleteTokenAsset(
    """
    The 'TokenAsset' document's ID
    """
    id: ID!
  ): TokenAsset

  """
  Update an existing document in the collection of 'Pin'
  """
  updatePin(
    """
    The 'Pin' document's ID
    """
    id: ID!

    """
    'Pin' input values
    """
    data: PinInput!
  ): Pin

  """
  Create a new document in the collection of 'Metadata'
  """
  createMetadata(
    """
    'Metadata' input values
    """
    data: MetadataInput!
  ): Metadata!

  """
  Delete an existing document in the collection of 'Token'
  """
  deleteToken(
    """
    The 'Token' document's ID
    """
    id: ID!
  ): Token

  """
  Create a new document in the collection of 'Block'
  """
  createBlock(
    """
    'Block' input values
    """
    data: BlockInput!
  ): Block!

  """
  Delete an existing document in the collection of 'ERC721ImportResult'
  """
  deleteERC721ImportResult(
    """
    The 'ERC721ImportResult' document's ID
    """
    id: ID!
  ): ERC721ImportResult

  """
  Update an existing document in the collection of 'Metadata'
  """
  updateMetadata(
    """
    The 'Metadata' document's ID
    """
    id: ID!

    """
    'Metadata' input values
    """
    data: MetadataInput!
  ): Metadata

  """
  Create a new document in the collection of 'TokenContract'
  """
  createTokenContract(
    """
    'TokenContract' input values
    """
    data: TokenContractInput!
  ): TokenContract!

  """
  Create a new document in the collection of 'PinLocation'
  """
  createPinLocation(
    """
    'PinLocation' input values
    """
    data: PinLocationInput!
  ): PinLocation!

  """
  Create a new document in the collection of 'Resource'
  """
  createResource(
    """
    'Resource' input values
    """
    data: ResourceInput!
  ): Resource!

  """
  Update an existing document in the collection of 'Cursor'
  """
  updateCursor(
    """
    The 'Cursor' document's ID
    """
    id: ID!

    """
    'Cursor' input values
    """
    data: CursorInput!
  ): Cursor

  """
  Delete an existing document in the collection of 'PinLocation'
  """
  deletePinLocation(
    """
    The 'PinLocation' document's ID
    """
    id: ID!
  ): PinLocation

  """
  Create a new document in the collection of 'Token'
  """
  createToken(
    """
    'Token' input values
    """
    data: TokenInput!
  ): Token!

  """
  Delete an existing document in the collection of 'Cursor'
  """
  deleteCursor(
    """
    The 'Cursor' document's ID
    """
    id: ID!
  ): Cursor
  importERC721(input: ERC721ImportInput!): ERC721ImportResult!
  updateResources(input: UpdateResourcesInput): [Resource!]!

  """
  Update an existing document in the collection of 'TokenContract'
  """
  updateTokenContract(
    """
    The 'TokenContract' document's ID
    """
    id: ID!

    """
    'TokenContract' input values
    """
    data: TokenContractInput!
  ): TokenContract

  """
  Delete an existing document in the collection of 'Resource'
  """
  deleteResource(
    """
    The 'Resource' document's ID
    """
    id: ID!
  ): Resource

  """
  Update an existing document in the collection of 'PinLocation'
  """
  updatePinLocation(
    """
    The 'PinLocation' document's ID
    """
    id: ID!

    """
    'PinLocation' input values
    """
    data: PinLocationInput!
  ): PinLocation

  """
  Update an existing document in the collection of 'Owner'
  """
  updateOwner(
    """
    The 'Owner' document's ID
    """
    id: ID!

    """
    'Owner' input values
    """
    data: OwnerInput!
  ): Owner
  updateTokenAsset(input: TokenAssetUpdate!): TokenAsset!

  """
  Delete an existing document in the collection of 'Block'
  """
  deleteBlock(
    """
    The 'Block' document's ID
    """
    id: ID!
  ): Block

  """
  Create a new document in the collection of 'TokenAsset'
  """
  createTokenAsset(
    """
    'TokenAsset' input values
    """
    data: TokenAssetInput!
  ): TokenAsset!

  """
  Delete an existing document in the collection of 'Pin'
  """
  deletePin(
    """
    The 'Pin' document's ID
    """
    id: ID!
  ): Pin

  """
  Create a new document in the collection of 'Cursor'
  """
  createCursor(
    """
    'Cursor' input values
    """
    data: CursorInput!
  ): Cursor!

  """
  Update an existing document in the collection of 'Token'
  """
  updateToken(
    """
    The 'Token' document's ID
    """
    id: ID!

    """
    'Token' input values
    """
    data: TokenInput!
  ): Token

  """
  Create a new document in the collection of 'Content'
  """
  createContent(
    """
    'Content' input values
    """
    data: ContentInput!
  ): Content!

  """
  Create a new document in the collection of 'ERC721ImportResult'
  """
  createERC721ImportResult(
    """
    'ERC721ImportResult' input values
    """
    data: ERC721ImportResultInput!
  ): ERC721ImportResult!

  """
  Delete an existing document in the collection of 'TokenContract'
  """
  deleteTokenContract(
    """
    The 'TokenContract' document's ID
    """
    id: ID!
  ): TokenContract

  """
  Create a new document in the collection of 'Owner'
  """
  createOwner(
    """
    'Owner' input values
    """
    data: OwnerInput!
  ): Owner!

  """
  Update an existing document in the collection of 'Content'
  """
  updateContent(
    """
    The 'Content' document's ID
    """
    id: ID!

    """
    'Content' input values
    """
    data: ContentInput!
  ): Content
  updateTokenAssets(input: UpdateTokenAssetsInput!): [TokenAsset!]!
  updateResource(input: ResourceUpdate): Resource!

  """
  Delete an existing document in the collection of 'Metadata'
  """
  deleteMetadata(
    """
    The 'Metadata' document's ID
    """
    id: ID!
  ): Metadata

  """
  Update an existing document in the collection of 'Block'
  """
  updateBlock(
    """
    The 'Block' document's ID
    """
    id: ID!

    """
    'Block' input values
    """
    data: BlockInput!
  ): Block

  """
  Delete an existing document in the collection of 'Content'
  """
  deleteContent(
    """
    The 'Content' document's ID
    """
    id: ID!
  ): Content

  """
  Update an existing document in the collection of 'ERC721ImportResult'
  """
  updateERC721ImportResult(
    """
    The 'ERC721ImportResult' document's ID
    """
    id: ID!

    """
    'ERC721ImportResult' input values
    """
    data: ERC721ImportResultInput!
  ): ERC721ImportResult
}

type Owner {
  """
  The document's ID.
  """
  _id: ID!

  """
  The document's timestamp.
  """
  _ts: Long!
  id: ID!
}

"""
'Owner' input values
"""
input OwnerInput {
  id: ID!
}

"""
Information for piece of content pinned in IPFS.
"""
type Pin {
  """
  Reference to a pin location that is pinning it.
  """
  location: PinLocation!

  """
  The document's ID.
  """
  _id: ID!

  """
  Human readable description of the pin status. Present only when status needs
  ellaboration e.g. when pin is failed or when pin is queued but actual status
  could not be obtained from the node.
  """
  statusText: String

  """
  Last time pin status was updated.
  """
  updated: Time!

  """
  Pinning status at this location.
  """
  status: PinStatus!

  """
  The content being pinned.
  """
  content: Content!

  """
  Time when pin was created.
  """
  created: Time!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
Allow manipulating the relationship between the types 'Pin' and 'Content' using the field 'Pin.content'.
"""
input PinContentRelation {
  """
  Create a document of type 'Content' and associate it with the current document.
  """
  create: ContentInput

  """
  Connect a document of type 'Content' with the current document using its ID.
  """
  connect: ID
}

"""
'Pin' input values
"""
input PinInput {
  """
  The content being pinned.
  """
  content: PinContentRelation

  """
  Reference to a pin location that is pinning it.
  """
  location: PinLocationRelation

  """
  Pinning status at this location.
  """
  status: PinStatus!

  """
  Human readable description of the pin status. Present only when status needs
  ellaboration e.g. when pin is failed or when pin is queued but actual status
  could not be obtained from the node.
  """
  statusText: String

  """
  Last time pin status was updated.
  """
  updated: Time!

  """
  Time when pin was created.
  """
  created: Time!
}

"""
Location of a pin.
"""
type PinLocation {
  """
  The document's ID.
  """
  _id: ID!

  """
  Libp2p peer ID of the node pinning this pin.
  """
  peerId: String!

  """
  Name of the peer pinning this pin.
  """
  peerName: String

  """
  Known pins at this location.
  """
  pins(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): PinPage!

  """
  Geographic region this node resides in.
  """
  region: String

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
'PinLocation' input values
"""
input PinLocationInput {
  """
  Known pins at this location.
  """
  pins: PinLocationPinsRelation

  """
  Libp2p peer ID of the node pinning this pin.
  """
  peerId: String!

  """
  Name of the peer pinning this pin.
  """
  peerName: String

  """
  Geographic region this node resides in.
  """
  region: String
}

"""
Allow manipulating the relationship between the types 'PinLocation' and 'Pin'.
"""
input PinLocationPinsRelation {
  """
  Create one or more documents of type 'Pin' and associate them with the current document.
  """
  create: [PinInput]

  """
  Connect one or more documents of type 'Pin' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Pin' from the current document using their IDs.
  """
  disconnect: [ID]
}

"""
Allow manipulating the relationship between the types 'Pin' and 'PinLocation' using the field 'Pin.location'.
"""
input PinLocationRelation {
  """
  Create a document of type 'PinLocation' and associate it with the current document.
  """
  create: PinLocationInput

  """
  Connect a document of type 'PinLocation' with the current document using its ID.
  """
  connect: ID
}

"""
The pagination object for elements of type 'Pin'.
"""
type PinPage {
  """
  The elements of type 'Pin' in this page.
  """
  data: [Pin]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

enum PinStatus {
  """
  An error occurred pinning.
  """
  PinFailed

  """
  Node has pinned the content.
  """
  Pinned

  """
  Node is currently pinning the content.
  """
  Pinning

  """
  The item has been queued for pinning.
  """
  PinQueued
}

type Query {
  """
  Find a document from the collection of 'Block' by its id.
  """
  findBlockByID(
    """
    The 'Block' document's ID
    """
    id: ID!
  ): Block

  """
  Find a document from the collection of 'TokenContract' by its id.
  """
  findTokenContractByID(
    """
    The 'TokenContract' document's ID
    """
    id: ID!
  ): TokenContract
  constract(id: ID): TokenContract

  """
  Provides tokens with the
  """
  findTokenAssets(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
    where: FindTokenAssetsInput
  ): QueryFindTokenAssetsPage!

  """
  Find a document from the collection of 'Resource' by its id.
  """
  findResourceByID(
    """
    The 'Resource' document's ID
    """
    id: ID!
  ): Resource

  """
  Find a document from the collection of 'Token' by its id.
  """
  findTokenByID(
    """
    The 'Token' document's ID
    """
    id: ID!
  ): Token
  findContentByCID(cid: ID): Content
  allImports(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): ERC721ImportResultPage!

  """
  Find a document from the collection of 'Owner' by its id.
  """
  findOwnerByID(
    """
    The 'Owner' document's ID
    """
    id: ID!
  ): Owner

  """
  Find a document from the collection of 'ERC721ImportResult' by its id.
  """
  findERC721ImportResultByID(
    """
    The 'ERC721ImportResult' document's ID
    """
    id: ID!
  ): ERC721ImportResult
  cursor: Cursor!

  """
  Find a document from the collection of 'Metadata' by its id.
  """
  findMetadataByID(
    """
    The 'Metadata' document's ID
    """
    id: ID!
  ): Metadata

  """
  Find a document from the collection of 'PinLocation' by its id.
  """
  findPinLocationByID(
    """
    The 'PinLocation' document's ID
    """
    id: ID!
  ): PinLocation
  block(hash: ID, number: Long): Block

  """
  Find a document from the collection of 'Content' by its id.
  """
  findContentByID(
    """
    The 'Content' document's ID
    """
    id: ID!
  ): Content

  """
  Find a document from the collection of 'Cursor' by its id.
  """
  findCursorByID(
    """
    The 'Cursor' document's ID
    """
    id: ID!
  ): Cursor
  findResources(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
    where: FindResourceInput
  ): QueryFindResourcesPage!

  """
  Find a document from the collection of 'TokenAsset' by its id.
  """
  findTokenAssetByID(
    """
    The 'TokenAsset' document's ID
    """
    id: ID!
  ): TokenAsset
  tokens(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
    tokenID: String
    mintTime: String
  ): TokenPage!
  owner(id: ID): Owner
  findResourceByURI(uri: String): Resource

  """
  Find a document from the collection of 'Pin' by its id.
  """
  findPinByID(
    """
    The 'Pin' document's ID
    """
    id: ID!
  ): Pin
  allTokens(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): TokenPage!
}

"""
The pagination object for elements of type 'Resource'.
"""
type QueryFindResourcesPage {
  """
  The elements of type 'Resource' in this page.
  """
  data: [Resource]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

"""
The pagination object for elements of type 'TokenAsset'.
"""
type QueryFindTokenAssetsPage {
  """
  The elements of type 'TokenAsset' in this page.
  """
  data: [TokenAsset]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

"""
Represents a resource that non-fungible token metadata referenced via URI. In
most cases when created will have `uri` discovered on chain with a status
`Queued`. Followup jobs will then attempt to locate and pin it's content
updating it's state.
"""
type Resource {
  """
  The document's ID.
  """
  _id: ID!

  """
  URI this resource corresponds to. Resources are created for all the URIs
  that NFT token metadata references.
  """
  uri: String!

  """
  Human readable description of the status. Would contain error message & stack
  trace when resource has failed status. Likely omitted when resource is queued
  or succefully linked.
  """
  statusText: String

  """
  Time when resource record was last updated.
  """
  updated: Time!

  """
  Represents `ipfs://` URL for this content. Sometimes this is derived when
  resource uri is parsed. E.g. if discovered resource uri was
  https://ipfs.io/ipfs/Qm...Hash/file/path it's ipfsURL will be derived
  to be ipfs://Qm...Hash/file/path.

  If `uri` can not be inferred as an ipfs URL this field will be omitted.
  """
  ipfsURL: String

  """
  Describes current status of the resource. When resource is discovered during
  chain scrape record is created with Queued state. Cron job later comes along
  and processes queued resources fetching / pinning them.
  """
  status: ResourceStatus!

  """
  Content referrerced by this resource. When `ipfsURL` is derived content
  archiving job will simply pin content by that URL and update resource linking
  resource to it. If however `ipfsURL` could not be derived archiving job will
  attempt to fetch the content from `uri` and pin it again linkking resource
  to it.

  Content field is only going to be present when resource has a `ContentLinked`
  status. From that point on resource is no longer going to be updated.
  """
  content: Content!

  """
  Backlinks to each non-fungible token metadata that referenced resource with
  this `uri`.
  """
  referrers(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): MetadataPage!

  """
  Time when resource was created.
  """
  created: Time!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
Allow manipulating the relationship between the types 'Resource' and 'Content' using the field 'Resource.content'.
"""
input ResourceContentRelation {
  """
  Create a document of type 'Content' and associate it with the current document.
  """
  create: ContentInput

  """
  Connect a document of type 'Content' with the current document using its ID.
  """
  connect: ID
}

input ResourceInput {
  uri: String!
  ipfsURL: String
}

"""
The pagination object for elements of type 'Resource'.
"""
type ResourcePage {
  """
  The elements of type 'Resource' in this page.
  """
  data: [Resource]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

input ResourceQuery {
  uri: String
  cid: String
}

"""
Allow manipulating the relationship between the types 'Resource' and 'Metadata'.
"""
input ResourceReferrersRelation {
  """
  Create one or more documents of type 'Metadata' and associate them with the current document.
  """
  create: [MetadataInput]

  """
  Connect one or more documents of type 'Metadata' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Metadata' from the current document using their IDs.
  """
  disconnect: [ID]
}

enum ResourceStatus {
  """
  Resource was queued to be processed.
  """
  Queued

  """
  URI is either malformed or the protocol is not supported.
  """
  URIParseFailed

  """
  Was unable to fetch the content.
  """
  ContentFetchFailed

  """
  Failed to complete a pin request.
  """
  PinRequestFailed

  """
  Corresponding content was linked.
  """
  ContentLinked
}

"""
Represents update of the individual resource.
"""
input ResourceUpdate {
  id: ID!

  """
  New status for the resource. Update will only apply when status moves forward
  Queued -> URIParseFailed -> ContentFetchFailed -> PinRequestFailed -> ContentLinked

  Skipping state is fine, however attempt to change status from e.g.
  ContentLinked to URIParseFailed is simply ignored.
  """
  status: ResourceStatus!

  """
  Status description.
  """
  statusText: String!

  """
  If IPFS URL was inferred from the uri this will be set. When passed status
  field should either be ContentFetchFailed or ContentLinked.
  """
  ipfsURL: String

  """
  If provided status should be `ContentLinked`.
  """
  cid: String
}

scalar Time

type Token {
  blocks(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): BlockPage!

  """
  The document's ID.
  """
  _id: ID!
  mintTime: String!
  id: String!
  imported(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): ERC721ImportResultPage!
  tokenID: String!
  owner: Owner!

  """
  Present when ERC721Metadata interface is implemented.
  """
  tokenAsset: TokenAsset
  contract: TokenContract!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
TokenAsset represents contents of the tokenURI which may not have been found /
pinned yet. It may have been added by the chain scraper, when token with this
`tokenURI` was discovered. Alternatively it could have been created by an
upload to nft.storage, in which case it may not have any refferers but it would
have uploads.
"""
type TokenAsset {
  """
  The document's ID.
  """
  _id: ID!

  """
  Human readable description of the status. Usually this ellaborates a reason
  why token analyzer has failed providing with an error message and stack trace.
  """
  statusText: String

  """
  URI that was discovered either in the eth chain.
  """
  tokenURI: String!

  """
  Time when resource record was last updated.
  """
  updated: Time!

  """
  Represents `ipfs://` URL for this content. Sometimes this is derived when
  resource uri is parsed. E.g. if discovered resource uri was
  https://ipfs.io/ipfs/Qm...Hash/file/path it's ipfsURL will be derived
  to be ipfs://Qm...Hash/file/path.

  If `uri` can not be inferred as an ipfs URL this field will be omitted.
  """
  ipfsURL: String

  """
  Status of the token asset
  """
  status: TokenAssetStatus!

  """
  When `tokenURI` points to JSON file that conforms to the ERC721 Metadata JSON
  Schema it is fetched parsed and stored as related Metadata document.
  """
  metadata: Metadata

  """
  Tokens that have this `tokenURI`. This relation allows us to identify all
  tokens that have a same `tokenURI`.
  """
  referrers(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): TokenPage!
  created: Time!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
'TokenAsset' input values
"""
input TokenAssetInput {
  """
  Tokens that have this `tokenURI`. This relation allows us to identify all
  tokens that have a same `tokenURI`.
  """
  referrers: TokenAssetReferrersRelation

  """
  URI that was discovered either in the eth chain.
  """
  tokenURI: String!

  """
  Represents `ipfs://` URL for this content. Sometimes this is derived when
  resource uri is parsed. E.g. if discovered resource uri was
  https://ipfs.io/ipfs/Qm...Hash/file/path it's ipfsURL will be derived
  to be ipfs://Qm...Hash/file/path.

  If `uri` can not be inferred as an ipfs URL this field will be omitted.
  """
  ipfsURL: String

  """
  When `tokenURI` points to JSON file that conforms to the ERC721 Metadata JSON
  Schema it is fetched parsed and stored as related Metadata document.
  """
  metadata: TokenAssetMetadataRelation
  created: Time!

  """
  Time when resource record was last updated.
  """
  updated: Time!

  """
  Status of the token asset
  """
  status: TokenAssetStatus!

  """
  Human readable description of the status. Usually this ellaborates a reason
  why token analyzer has failed providing with an error message and stack trace.
  """
  statusText: String
}

"""
Allow manipulating the relationship between the types 'TokenAsset' and 'Metadata' using the field 'TokenAsset.metadata'.
"""
input TokenAssetMetadataRelation {
  """
  Create a document of type 'Metadata' and associate it with the current document.
  """
  create: MetadataInput

  """
  Connect a document of type 'Metadata' with the current document using its ID.
  """
  connect: ID
}

"""
Allow manipulating the relationship between the types 'TokenAsset' and 'Token'.
"""
input TokenAssetReferrersRelation {
  """
  Create one or more documents of type 'Token' and associate them with the current document.
  """
  create: [TokenInput]

  """
  Connect one or more documents of type 'Token' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Token' from the current document using their IDs.
  """
  disconnect: [ID]
}

enum TokenAssetStatus {
  """
  Token asset was queued (for the analyzer to process).
  """
  Queued

  """
  tokenURI is either malformed or the protocol is not supported.
  """
  URIParseFailed

  """
  Was unable to fetch the content.
  """
  ContentFetchFailed

  """
  Parsing ERC721 metadata failed.
  """
  ContentParseFailed

  """
  Failed to create a metadata pin request.
  """
  PinRequestFailed

  """
  Metadata was parsed and all the resources were linked.
  """
  Linked
}

input TokenAssetUpdate {
  id: ID!

  """
  If IPFS URL was inferred from the uri this will be set. When passed status
  field should either be ContentFetchFailed or ContentLinked.
  """
  ipfsURL: String
  status: TokenAssetStatus!
  statusText: String!
  metadata: MetadataInput
}

"""
Allow manipulating the relationship between the types 'Token' and 'Block'.
"""
input TokenBlocksRelation {
  """
  Create one or more documents of type 'Block' and associate them with the current document.
  """
  create: [BlockInput]

  """
  Connect one or more documents of type 'Block' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Block' from the current document using their IDs.
  """
  disconnect: [ID]
}

type TokenContract {
  """
  A descriptive name for a collection of NFTs in this contract
  """
  name: String

  """
  The document's ID.
  """
  _id: ID!

  """
  An abbreviated name for NFTs in this contract
  """
  symbol: String
  id: ID!
  supportsEIP721Metadata: Boolean!
  tokens(
    """
    The number of items to return per page.
    """
    _size: Int

    """
    The pagination cursor.
    """
    _cursor: String
  ): TokenPage!

  """
  The document's timestamp.
  """
  _ts: Long!
}

"""
'TokenContract' input values
"""
input TokenContractInput {
  id: ID!

  """
  A descriptive name for a collection of NFTs in this contract
  """
  name: String

  """
  An abbreviated name for NFTs in this contract
  """
  symbol: String
  supportsEIP721Metadata: Boolean!
  tokens: TokenContractTokensRelation
}

"""
Allow manipulating the relationship between the types 'Token' and 'TokenContract' using the field 'Token.contract'.
"""
input TokenContractRelation {
  """
  Create a document of type 'TokenContract' and associate it with the current document.
  """
  create: TokenContractInput

  """
  Connect a document of type 'TokenContract' with the current document using its ID.
  """
  connect: ID
}

"""
Allow manipulating the relationship between the types 'TokenContract' and 'Token'.
"""
input TokenContractTokensRelation {
  """
  Create one or more documents of type 'Token' and associate them with the current document.
  """
  create: [TokenInput]

  """
  Connect one or more documents of type 'Token' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'Token' from the current document using their IDs.
  """
  disconnect: [ID]
}

"""
Allow manipulating the relationship between the types 'Token' and 'ERC721ImportResult'.
"""
input TokenImportedRelation {
  """
  Create one or more documents of type 'ERC721ImportResult' and associate them with the current document.
  """
  create: [ERC721ImportResultInput]

  """
  Connect one or more documents of type 'ERC721ImportResult' with the current document using their IDs.
  """
  connect: [ID]

  """
  Disconnect the given documents of type 'ERC721ImportResult' from the current document using their IDs.
  """
  disconnect: [ID]
}

"""
'Token' input values
"""
input TokenInput {
  id: String!
  tokenID: String!
  mintTime: String!

  """
  Present when ERC721Metadata interface is implemented.
  """
  tokenAsset: TokenTokenAssetRelation
  contract: TokenContractRelation
  owner: TokenOwnerRelation
  blocks: TokenBlocksRelation
  imported: TokenImportedRelation
}

"""
Allow manipulating the relationship between the types 'Token' and 'Owner' using the field 'Token.owner'.
"""
input TokenOwnerRelation {
  """
  Create a document of type 'Owner' and associate it with the current document.
  """
  create: OwnerInput

  """
  Connect a document of type 'Owner' with the current document using its ID.
  """
  connect: ID
}

"""
The pagination object for elements of type 'Token'.
"""
type TokenPage {
  """
  The elements of type 'Token' in this page.
  """
  data: [Token]!

  """
  A cursor for elements coming after the current page.
  """
  after: String

  """
  A cursor for elements coming before the current page.
  """
  before: String
}

"""
Allow manipulating the relationship between the types 'Token' and 'TokenAsset' using the field 'Token.tokenAsset'.
"""
input TokenTokenAssetRelation {
  """
  Create a document of type 'TokenAsset' and associate it with the current document.
  """
  create: TokenAssetInput

  """
  Connect a document of type 'TokenAsset' with the current document using its ID.
  """
  connect: ID

  """
  If true, disconnects this document from 'TokenAsset'
  """
  disconnect: Boolean
}

input UpdateResourcesInput {
  updates: [ResourceUpdate!]!
}

input UpdateTokenAssetsInput {
  updates: [TokenAssetUpdate!]!
}
